class QRNGService{constructor(){this.cache={uint8:[],uint16:[],hex8:[],hex16:[]},this.cacheSize={uint8:1e3,uint16:500,hex8:200,hex16:100},this.requestInProgress={},this.eventListeners=new Map}addEventListener(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,[]),this.eventListeners.get(e).push(t)}emit(e,t={}){this.eventListeners.has(e)&&this.eventListeners.get(e).forEach(e=>{try{e({...t,timestamp:(new Date).toISOString()})}catch(e){}})}async getQuantumData(e,t,s=null,r=!0){if(this.emit("request",{type:e,count:t,size:s,useCache:r}),!["uint8","uint16","hex8","hex16"].includes(e))throw new Error(`Invalid type: ${e}`);if(t<=0||t>1024)throw new Error(`Invalid count: ${t}. Must be between 1 and 1024`);if(r&&this.cache[e].length>=t){const r=this.cache[e].splice(0,t);return this.emit("cache_hit",{type:e,count:t,remaining:this.cache[e].length}),this.cache[e].length<.3*this.cacheSize[e]&&this.refillCache(e,s).catch(()=>{}),r}this.emit("cache_miss",{type:e,count:t,cacheSize:this.cache[e].length});try{const i=await this.fetchFromAPI(e,t,s);if(r&&i.length>t){const s=i.splice(t);this.cache[e].unshift(...s),this.cache[e]=this.cache[e].slice(0,this.cacheSize[e])}return this.emit("success",{type:e,count:t,fetched:i.length}),i}catch(s){throw this.emit("error",{type:e,count:t,error:s.message}),s}}async fetchFromAPI(e,t,s=null){const r=new URLSearchParams({type:e,length:t.toString()});s&&["hex8","hex16"].includes(e)&&r.append("size",s.toString());const i=`${e}_${t}_${s}`;if(this.requestInProgress[i])return this.requestInProgress[i];try{this.requestInProgress[i]=this._makeRequest(r);const e=await this.requestInProgress[i];if(!e.ok){const t=await e.json();throw new Error(t.error||`HTTP ${e.status}`)}const t=await e.json();if(!t.success)throw new Error(t.error||"API request failed");return t.data}finally{delete this.requestInProgress[i]}}async _makeRequest(e,t=2){const s=new AbortController,r=setTimeout(()=>s.abort(),15e3);try{const t=await fetch(`/api/qrng?${e}`,{signal:s.signal,headers:{Accept:"application/json"}});return clearTimeout(r),t}catch(s){if(clearTimeout(r),"AbortError"===s.name){if(t>0)return this._makeRequest(e,t-1);throw new Error("Request timeout after retries")}throw s}}async refillCache(e,t=null){try{const s=this.cacheSize[e]-this.cache[e].length;if(s<=0)return;const r=Math.min(2*s,1024),i=await this.fetchFromAPI(e,r,t);this.cache[e].push(...i),this.cache[e]=this.cache[e].slice(0,this.cacheSize[e])}catch(e){}}async prewarmCaches(){await Promise.allSettled(["uint8","uint16"].map(e=>this.refillCache(e)))}getCacheStatus(){return Object.entries(this.cache).map(([e,t])=>({type:e,count:t.length,capacity:this.cacheSize[e],percentage:Math.round(t.length/this.cacheSize[e]*100)}))}clearCache(){Object.keys(this.cache).forEach(e=>{this.cache[e]=[]})}async getHealth(){try{const e=await fetch("/api/health");return await e.json()}catch(e){return{status:"error",error:e.message}}}async getUint8(e,t=!0){return this.getQuantumData("uint8",e,null,t)}async getUint16(e,t=!0){return this.getQuantumData("uint16",e,null,t)}async getHex8(e,t=1,s=!0){return this.getQuantumData("hex8",e,t,s)}async getHex16(e,t=1,s=!0){return this.getQuantumData("hex16",e,t,s)}}const qrngService=new QRNGService;"loading"===document.readyState?document.addEventListener("DOMContentLoaded",()=>{qrngService.prewarmCaches()}):qrngService.prewarmCaches(),window.qrngService=qrngService;